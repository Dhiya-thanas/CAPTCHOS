<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Image-Selection CAPTCHA — Retro Tech</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

<style>
  :root{
    --bg:#000;
    --accent:#00ff66;
    --muted:#003311;
    --panel:rgba(0,26,0,0.9);
    --text:#c6f9d4;
  }

  html,body{height:100%;margin:0;background:var(--bg);font-family:'Press Start 2P',monospace;color:var(--text);}

  /* subtle blurred website-like background placeholder */
  .bg-placeholder{
    position:fixed;inset:0;background:
      linear-gradient(120deg,#04202488,#00111488);
    filter:blur(1px) brightness(.7); z-index:0;
  }

  /* overlay scanlines to keep retro vibe */
  .scanlines{
    position:fixed;inset:0;
    background:repeating-linear-gradient(
      to bottom,
      rgba(0,255,102,0.02),
      rgba(0,255,102,0.02) 1px,
      transparent 1px,
      transparent 3px
    );
    z-index:1;pointer-events:none;
  }

  main{
    position:relative; z-index:2;
    min-height:100vh;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    padding:20px;
  }

  .panel{
    width: min(92%,540px);
    background:var(--panel);
    border:2px solid var(--accent);
    box-shadow: 0 0 20px rgba(0,255,102,0.12);
    padding:18px;
    text-align:center;
  }

  h1{font-size:16px;margin:0 0 12px;color:var(--accent);text-shadow:0 0 6px #003311;}
  p.instruction{font-size:10px;margin:6px 0 14px;color:#b7f6c9;}

  /* grid */
  .grid{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:10px;
    justify-items:center;
  }

  .tile{
    width:140px;height:100px;
    background:#111;border:2px solid #052;
    display:flex;align-items:center;justify-content:center;
    position:relative;cursor:pointer;overflow:hidden;
  }

  .tile img{
    width:100%;height:100%;object-fit:cover;display:block;filter:contrast(0.95) saturate(0.8);
    transform-origin:center center;transition:transform .18s linear;
  }

  .tile .overlay{
    position:absolute;inset:0;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.35));
    pointer-events:none;
  }

  .tile .check {
    position:absolute; top:6px; right:6px; width:22px; height:22px;
    border-radius:4px; border:2px solid rgba(0,255,102,0.85);
    background:rgba(0,0,0,0.4); display:flex;align-items:center;justify-content:center;
    font-size:10px;color:var(--accent);opacity:0; transform:scale(.85); transition:all .12s ease;
  }

  .tile.selected img{ transform:scale(1.06) grayscale(0.0); box-shadow:0 0 10px rgba(0,255,102,0.12); }
  .tile.selected .check{ opacity:1; transform:scale(1); }

  /* controls */
  .controls{display:flex;gap:8px;justify-content:center;margin-top:14px;flex-wrap:wrap;}
  button, input[type="button"]{
    font-family:'Press Start 2P',monospace;
    background:#052b07;border:2px solid var(--accent); color:var(--accent);
    padding:8px 12px;font-size:10px;cursor:pointer;border-radius:4px;
  }
  button:hover{background:var(--muted);}

  .status{
    margin-top:12px;font-size:11px;color:#9ff7b8;
    min-height:20px;
  }

  /* helper: small screens */
  @media (max-width:420px){
    .tile{width:95px;height:70px;}
    .panel{padding:12px;}
  }
</style>
</head>
<body>

<div class="bg-placeholder" aria-hidden="true"></div>
<div class="scanlines" aria-hidden="true"></div>

<main>
  <div class="panel" role="region" aria-label="Image CAPTCHA">
    <h1>SECURITY CHECK</h1>
    <p class="instruction" id="instruction">Loading challenge...</p>

    <div class="grid" id="grid" aria-live="polite" aria-atomic="true">
      <!-- Tiles injected here -->
    </div>

    <div class="controls">
      <button id="refreshBtn" title="New challenge">NEW CHALLENGE</button>
      <button id="verifyBtn" title="Verify selection">VERIFY</button>
    </div>

    <div class="status" id="status" aria-live="polite"></div>
  </div>
</main>

<script>
/*
  Simple client-side image-selection CAPTCHA prototype.
  - Not secure for production as-is.
  - Uses a small set of public images (Wikimedia) for demo.
  - Randomizes image order and challenges.
*/

const GRID_SIZE = 9; // 3x3 grid
const gridEl = document.getElementById('grid');
const instructionEl = document.getElementById('instruction');
const statusEl = document.getElementById('status');
const refreshBtn = document.getElementById('refreshBtn');
const verifyBtn = document.getElementById('verifyBtn');

let currentChallenge = null; // { prompt, matches: [ids], images: [...] }
let selectedSet = new Set();

// A small demo dataset of labeled images (public domain / Wikimedia)
const IMAGE_POOL = [
  // cats
  { id: 'cat1', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg', labels: ['cat','animal'] },
  { id: 'cat2', url: 'https://upload.wikimedia.org/wikipedia/commons/6/69/June_odd-eyed-cat.jpg', labels: ['cat','animal'] },
  // dogs
  { id: 'dog1', url: 'https://upload.wikimedia.org/wikipedia/commons/6/6e/Golde33443.jpg', labels: ['dog','animal'] },
  { id: 'dog2', url: 'https://upload.wikimedia.org/wikipedia/commons/1/15/White_shepherd.jpg', labels: ['dog','animal'] },
  // cars
  { id: 'car1', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3f/Ford_Mustang_2018.jpg', labels: ['car','vehicle'] },
  { id: 'car2', url: 'https://upload.wikimedia.org/wikipedia/commons/9/9f/2018_Toyota_Camry_SE_front_6.18.18.jpg', labels: ['car','vehicle'] },
  // buses
  { id: 'bus1', url: 'https://upload.wikimedia.org/wikipedia/commons/4/47/London_bus_Routemaster.jpg', labels: ['bus','vehicle'] },
  // floppy disks / retro tech
  { id: 'floppy', url: 'https://upload.wikimedia.org/wikipedia/commons/5/5a/Floppy_disk_2009_G1.jpg', labels: ['floppy disk','disk','retro'] },
  // keyboard
  { id: 'keyboard', url: 'https://upload.wikimedia.org/wikipedia/commons/6/6f/Mechanical_keyboard.jpg', labels: ['keyboard','device','computer'] },
  // phones
  { id: 'phone', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3b/IPhone_12_Pro.png', labels: ['phone','device'] },
  // airplanes
  { id: 'plane', url: 'https://upload.wikimedia.org/wikipedia/commons/3/3e/Boeing_747-400_in_flight.jpg', labels: ['plane','vehicle'] }
];

// Challenge templates: prompt text and label to match
const CHALLENGES = [
  { prompt: 'Select all images containing a cat', label: 'cat' },
  { prompt: 'Select all images containing a dog', label: 'dog' },
  { prompt: 'Select all images containing a car', label: 'car' },
  { prompt: 'Select all images of vehicles', label: 'vehicle' },
  { prompt: 'Select all images of retro tech (floppy disk, keyboard)', label: 'retro' },
  { prompt: 'Select all images that contain a phone', label: 'phone' }
];

function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}

// Build a random 3x3 challenge
function buildChallenge(){
  selectedSet.clear();
  gridEl.innerHTML = '';
  statusEl.textContent = '';
  // pick a challenge randomly
  const challenge = CHALLENGES[Math.floor(Math.random()*CHALLENGES.length)];
  // pick images for the grid - ensure we include at least 2 matches (if available)
  const pool = IMAGE_POOL.slice();
  shuffle(pool);

  // find images that match challenge label
  const matches = pool.filter(img => img.labels.includes(challenge.label));
  // Ensure at least one matching image — if none, fall back to a different challenge
  if(matches.length === 0){
    // try fallback to a challenge that has matches
    const available = CHALLENGES.find(c => IMAGE_POOL.some(img=>img.labels.includes(c.label)));
    if(!available){
      instructionEl.textContent = 'No image challenges available.';
      return;
    } else {
      return buildSpecificChallenge(available);
    }
  }
  return buildSpecificChallenge(challenge);
}

function buildSpecificChallenge(challenge){
  // produce grid images: select N images mixing matches & non-matches
  const pool = IMAGE_POOL.slice();
  shuffle(pool);

  // collect all that match
  const matchingAll = pool.filter(img => img.labels.includes(challenge.label));
  // collect non-matching
  const nonMatching = pool.filter(img => !img.labels.includes(challenge.label));

  // Guarantee at least 2 matches (or all matches if fewer exist)
  const needMatches = Math.min(3, Math.max(1, matchingAll.length >= 2 ? 2 : matchingAll.length));
  const chosen = [];
  // take some matches
  for(let i=0;i<needMatches;i++){
    if(matchingAll[i]) chosen.push(matchingAll[i]);
  }
  // fill remaining slots with non-matching or other images
  let idx=0;
  while(chosen.length < 9 && idx < pool.length){
    const candidate = pool[idx++];
    if(!chosen.some(x=>x.id===candidate.id)) chosen.push(candidate);
  }
  shuffle(chosen);

  // Build UI tiles
  gridEl.innerHTML = '';
  chosen.slice(0,9).forEach((img, index)=>{
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.setAttribute('data-id', img.id);
    tile.setAttribute('role','button');
    tile.setAttribute('aria-pressed','false');
    tile.setAttribute('tabindex',0);

    const imageEl = document.createElement('img');
    imageEl.src = img.url;
    imageEl.alt = 'captcha image';
    imageEl.loading = 'lazy';

    const overlay = document.createElement('div'); overlay.className='overlay';
    const check = document.createElement('div');
    check.className='check';
    check.innerHTML = '&#10003;';

    tile.appendChild(imageEl);
    tile.appendChild(overlay);
    tile.appendChild(check);

    // click / keyboard handlers
    tile.addEventListener('click', ()=> toggleTile(tile));
    tile.addEventListener('keydown', (e)=>{
      if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggleTile(tile); }
    });

    gridEl.appendChild(tile);
  });

  // store challenge info for verification
  currentChallenge = {
    prompt: challenge.prompt,
    label: challenge.label,
    gridIds: Array.from(gridEl.querySelectorAll('.tile')).map(t=>t.dataset.id)
  };

  instructionEl.textContent = currentChallenge.prompt;
}

// toggles selection
function toggleTile(tile){
  const id = tile.dataset.id;
  if(tile.classList.contains('selected')){
    tile.classList.remove('selected');
    tile.setAttribute('aria-pressed','false');
    selectedSet.delete(id);
  } else {
    tile.classList.add('selected');
    tile.setAttribute('aria-pressed','true');
    selectedSet.add(id);
  }
}

// verify selection against ground truth
function verify(){
  if(!currentChallenge) { statusEl.textContent = 'No challenge loaded.'; return; }
  // compute which grid images match the challenge label
  const correctIds = currentChallenge.gridIds.filter(id=>{
    const img = IMAGE_POOL.find(x=>x.id===id);
    return img && img.labels.includes(currentChallenge.label);
  });

  // compare sets: user selection must equal correctIds set
  const sel = Array.from(selectedSet);
  // normalize (lowercase ids are same)
  const selSet = new Set(sel);
  const correctSet = new Set(correctIds);

  // check equality
  const equal = selSet.size === correctSet.size && [...selSet].every(x => correctSet.has(x));

  if(equal){
    statusEl.textContent = '✅ Verification passed — you look human.';
    // for demonstration you could call server-side verification here
    // optionally show a token, allow form submit, etc.
  } else {
    statusEl.textContent = '❌ Verification failed — try again.';
  }
}

// event hooks
refreshBtn.addEventListener('click', ()=>{ buildChallenge(); });
verifyBtn.addEventListener('click', (e)=>{ e.preventDefault(); verify(); });

// initialize on load
buildChallenge();

</script>
</body>
</html>